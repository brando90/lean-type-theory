\section{Introduction}
\subsection{Type theory in programming languages}
The history of types in mathematical logic dates back to Frege's \emph{Begriffsschrift} \cite{frege}, which establishes a notation system for what amounts to second-order logic with equality. Bertrand Russell discovered a paradox in Frege's system: The predicate $P(A):=\neg A(A)$ leads to a contradiction (or in set-theoretic notation, the set $S=\{x\mid x\notin x\}$ cannot be a set). In reaction, Ernst Zermelo resolved the contradiction by imposing a ``size restriction'' on sets, leading to Zermelo set theory and eventually to Zermelo-Fraenkel set theory (ZFC), which has become the gold standard for axiomatization in modern mathematics. This yields an untyped but stratified view of the universe of mathematical concepts.

Russell's own reaction to Russell's paradox was instead to impose a stratification on the language itself, rejecting the expressions $A(A)$ or $x\in x$ as ``ill-typed''. This line of reasoning says that $A$ is not an object that predicates on objects of the same type as itself, so the notion is prima facie ill-formed. This idea is developed in \emph{Principia Mathematica} \cite{principia} and Quine's New Foundations \cite{quinenf}, but the most relevant application was to the simply typed $\lambda$-calculus \cite{churchstt} by Church (1940).

Somewhat independently, programming languages rediscovered the idea of a type \cite{typesoftypes}. Early programming languages had no explicit notion of type. Lisp used an evaluation model closely related to the untyped $\lambda$-calculus. FORTRAN (1956) had ``modes'' of expressions, either fixed or floating point. Algol 60 (1960) developed expressions and variables of type (\textbf{integer}, \textbf{real}, \textbf{Boolean}), and the extension Algol W by Wirth and Hoare (1966) developed a generative syntax for types including record types and typed references.

The logical and programming traditions are finally explicitly connected in the Curry-Howard isomorphism \cite{curryhoward}, which observed the connection between logical derivations (in the sequent calculus) and lambda terms in the simply typed $\lambda$-calculus. (In the same correspondence, Howard also discusses extensions to first order logic, with lambdas ranging over ``number variables'' $(\lambda x.\,F^\beta)^{\forall x\,\beta}$ separate from typed lambdas $(\lambda X^\alpha.\,F^\beta)^{\alpha\supset\beta}$.) But dependent type theory really begins in earnest with Per Martin-L\"{o}f \cite{martinlof}, who set the foundations for Brouwer's intuitionistic type theory as an outgrowth of the simply typed $\lambda$-calculus with dependent types.

Martin-L\"{o}f describes how constructive type theory can be used in programming languages:
\begin{quote}
By choosing to program in a formal language for constructive mathematics, like the theory of types, one gets access to the whole conceptual apparatus of pure mathematics, neglecting those parts that depend critically on the law of excluded middle, whereas even the best high level programming languages so far designed are wholly inadequate as mathematical languages (and, of course, nobody has claimed them to be so). In fact, I do not think that the search for logically ever more satisfactory high level programming languages can stop short of anything but a language in which (constructive) mathematics can be adequately expressed. \cite{martinlofprog}
\end{quote}

This dream was converted to action by Coquand and Huet, who introduced the Calculus of Constructions (\textsf{CoC}) \cite{coquandcoc} and developed it into an interactive proof assistant \textsf{Coq} \cite{coqart}. This type theory was extended with inductive types \cite{dybjer} to form the Calculus of Inductive Constructions (\textsf{CIC}) \cite{paulincic}.

Lean \cite{demoura} is a theorem prover based on \textsf{CIC} as well, with some subtle but important differences. The goal of this paper is to demonstrate the consequences of these differences, all taken together. While \textsf{CIC} itself is well-studied \cite{barrassets, barrastypedec, coqincoq}, most papers study subsystems of the actual axiomatic system implemented in Coq, which might be called $\mathsf{CIC^+}$ for its many small extensions added over the years. While we will not analyze $\mathsf{CIC^+}$ in this paper, we will be able to analyze all the extensions that are in Lean \textsf{CIC}, so our proof of consistency is directly applicable to the full Lean kernel. (See \autoref{sec:notcoq} for the possible issues that can come up in trying to extend this analysis to $\mathsf{CIC^+}$.)

\subsection{Set theoretic models of type theory}
Martin-L\"{o}f type theory has a relatively obvious model, in which types are interpreted as sets, and terms of that type are interpreted as elements of the corresponding sets. Essentially, this amounts to treating ``function types'' like $A\to B$ as literal sets of ZFC-encoded functions (sets of ordered pairs). Since most of the type theoretic intuition and terminology is inherited from this context, from the point of view of standard mathematics it is reasonable to expect that this should work as a model, and conversely we can use this model to guide our expectations for the reasonableness of variations on the rules of type theory.

In this model the easiest way to accomodate propositions is to have a two element universe $\mathsf{Prop}=\{0,1\}$, where the two elements are propositions $0=\emptyset$ and $1=\{\bullet\}$, where $\bullet$ is the ``trivial proof of $\mathsf{true}$''. This makes the model \emph{proof-irrelevant}, in the sense that proofs of a proposition are not distinguished in the model. This is great for type theories that have proof irrelevance in some form (also known as axiom K or uniqueness of identity proofs (UIP)), but contradicts homotopy type theory (HoTT) \cite{hottbook}, since the axiom of univalence is inconsistent with UIP. (Since definitional UIP is an axiom of Lean, we will not pursue models of HoTT further in this paper.)

This model is also tailored for \emph{impredicativity} of the universe of propositions. That is, the type theory allows propositions to quantify over elements in ``large universes''. To a mathematician accustomed to set theory, this may seem a non-issue, but impredicativity is quite axiomatically strong and corresponds to having ``full powersets'' in the ZFC sense. For predicative type theories, such as the axiom system used by Agda \cite{agda}, the impredicative model will work but is in some sense ``overkill''; here the preference is for models based on partial equivalence relations on terms, which avoids large cardinals.

Universes of CIC are closed under function types and inductive types, which when translated to the set theoretic language implies that they are Grothendieck universes. If we limit our attention to levels of the cumulative hierarchy $V_\lambda$, this amounts to a requirement that $\lambda$ be an inaccessible cardinal. Since Lean has an infinite sequence of universes this translates to having $\omega$ many inaccessible cardinals in the ZFC universe from which to build the model, and this is the main large cardinal axiom we require. It is not difficult to see that this assumption (or something with similar consistency strength) is necessary, because with a suitably defined inductive type we can construct a model of ZFC in each universe above the first one, and moreover we can define particular inaccessible cardinals in the larger models, so that we can have models of ZFC with $n$ inaccessible cardinals.

In ``Sets in Types, Types in Sets'' \cite{setsintypes}, Werner demonstrates the equiconsistency of $\mathsf{ZFC}_\omega$ and $\mathsf{CIC}_\omega$ by showing that $\mathsf{ZFC}_n\vdash\mathrm{Con}(\mathsf{CIC}_{n+1})$ and $\mathsf{CIC}_{n+2}\vdash\mathrm{Con}(\mathsf{ZFC}_n)$, where $\mathsf{ZFC}_n$ is $\mathsf{ZFC}$ with $n$ inaccessible cardinals and $\mathsf{CIC}_n$ is $\mathsf{CIC}$ with $n$ universes, and $\mathsf{ZFC}_\omega$ and $\mathsf{CIC}_\omega$ are the unions of these theories over $n<\omega$. Werner's construction of a model of set theory in CIC (in Coq) has been replicated in Lean with only minor modifications, so we can also claim $\mathsf{Lean}_{n+2}\vdash\mathrm{Con}(\mathsf{ZFC}_n)$ for essentially the same reasons.

The present work establishes the reverse direction $\mathsf{ZFC}_{n+1}\vdash\mathrm{Con}(\mathsf{Lean}_{n+1})$, so that $\mathsf{Lean}_\omega$ (or just $\mathsf{Lean}$) is also equiconsistent with $\mathsf{ZFC}_\omega$ and $\mathsf{CIC}_\omega$. We don't attempt to be precise with the universe bounds, but if we wanted to get a result like Werner's $\mathsf{ZFC}_n\vdash\mathrm{Con}(\mathsf{CIC}_{n+1})$, we would have to assume an axiom of global choice in $\mathsf{ZFC}$ (i.e. there is a proper class choice function on the universe $V$) to interpret Lean's $\mathsf{choice}$ axiom.

To some degree one can view this work as merely an elaboration of Werner's work in the context of Lean in place of Coq. However, we believe that inductive types in CIC, and Lean, are more complicated than they appear from simple worked examples, and we wanted to ensure that we correctly model the entire language, including all the edge case features that interact in unusual ways. In fact, as we shall see, a combination of subsingleton eliminating inductive types and definitional proof irrelevance breaks the decidability of Lean's type system, making a number of desirable properties fail to hold. In the light of this, as well as some historical soundness bugs in Coq as a result of unusual features in inductive specifications or pattern matching \cite{soundnessbug}, we felt it important to write down the complete axiomatic basis for Lean's type system, and work from there. See \autoref{sec:axioms} for the specification.

In ``The not so simple proof irrelevant model of CC'' \cite{notsosimple}, Miquel and Werner detail an issue that arises in proof irrelevant models such as the one described here. In short, without knowing the universe in which an expression or type lives, it becomes difficult to translate the Pi type over propositions differently than the Pi type over other universes, as one must, in order to ensure that $U_0=\{\emptyset,\{\bullet\}\}$ can serve as the boolean universe of propositions. This issue arises here as well, and the key step in overcoming it is the unique typing property. While this is mostly trivial in the context of PTSs for \cite{notsosimple}, in Lean this is a tricky syntactic argument, proven in \autoref{sec:unique}. While it is inspired by the Tait--Martin-L\"{o}f proof of the Church--Rosser theorem \cite{taitmartinlof}, definitional proof irrelevance causes many new difficulties, and the proof is novel to our knowledge.

In \cite{barrassets}, Barras uses a simple and ingenious trick to uniformize the treatment of the proof irrelevant universe of propositions with other universes - to use Aczel's encoding of functions, $f:=\{(x,y)\mid x\in\mathrm{dom}(f)\wedge y\in f(x)\}$, which has the property that $(x\in A\mapsto\bullet)=\bullet$ if we interpret $\bullet$ as the empty set. This simple property means that we don't need to determine the sorts of types and elements in the construction, and so we can avoid the dependency on unique typing in the proof of soundness. So if our only goal was proving soundness we could skip \autoref{sec:unique} entirely. Nevertheless, it is a useful property to have, and with it we can use the straightforward ZFC encoding for functions.

The remainder of the paper is organized as follows. \hyperref[sec:axioms]{Section~\ref*{sec:axioms}} details the type system of Lean in formal notation. \hyperref[sec:props]{Section~\ref*{sec:props}} does some basic metatheory of the type system, and in particular shows a number of negative results stemming from lack of decidability of the type system. \hyperref[sec:unique]{Section~\ref*{sec:unique}} is the proof of unique typing of the type system (even including the undecidable bits). \hyperref[sec:wtype]{Section~\ref*{sec:wtype}} shows how all inductive types can be reduced to a finite basis of 8 particular, basic inductive types. \hyperref[sec:soundness]{Section~\ref*{sec:soundness}} is the soundness theorem, which constructs the aforementioned set theoretic model for the $\W$ basis in detail.
